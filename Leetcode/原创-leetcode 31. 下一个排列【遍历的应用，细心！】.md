# 原创：leetcode 31. 下一个排列【遍历的应用，细心！】

**执行用时 : 8 ms, 在Next Permutation的C++提交中击败了99.64% 的用户**

**内存消耗 : 8.7 MB, 在Next Permutation的C++提交中击败了80.36% 的用户**

**逻辑一定要理清楚。**

### 具体可以参考leetcode的官方教程：（我加了注解）

### 结合动图：（注意最后有一次排序（逆序），别忘了）

 

> 
<ol>- 设i是倒数第二个结点，j是倒数第一个。i--，j--，直到：
- 从右往左找到第一个拐点——**nums[i]第一次小于nums[j]的地方。**
- 然后固定i不动，j往右边寻路，找从右边数第一个刚好nums[j]**大于**nums[i]的 地方（易错点！！！！！nums[j]不能等于num[i]，不然交换没有意义，而且整个逻辑就崩了）。
- 然后交换完后，i的右边应该保持最小字典序，这样才能是刚好在上一个自动序之后。**不需要sort，reverse就行**。因为右边本来就是有序的。
</ol>

 

 
