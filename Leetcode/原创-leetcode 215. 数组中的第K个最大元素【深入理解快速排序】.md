# 原创：leetcode 215. 数组中的第K个最大元素【深入理解快速排序】

方法一：

理解题目很简单。思路很清晰。最慢的复杂度应该是O（nlogn）。

先排序，再查找。

**执行用时 :16 ms, 在所有C++提交中击败了91.91%的用户**

**内存消耗 :9.4 MB, 在所有C++提交中击败了46.39%的用户**

...你仿佛在逗我。这都可以超过90%。

方法二：

能不能把时间复杂度降低到O（n）。

（1）首先，需要知道的是，这种最值问题肯定是需要完全遍历的。

 

想法一：如果维护一个长度为4的数组，如果来了一个元素大于最最末尾的，就往后移。那么实际上平均时间复杂度类似于冒泡排序。。<br/>
想法二：参考的题解。其中提到了用优先队列建立小跟堆的方法：

我寻思也没那么快：

**执行用时 :20 ms, 在所有C++提交中击败了72.22%的用户**

**内存消耗 :9.6 MB, 在所有C++提交中击败了33.50%的用户**

 

# 标准解法：

既然遍历所有元素是必要条件，那么：

> 
**类似快排的划分思路**<br/>**先任取一个数，把比它大的数移动到它的左边，比它小的数移动到它的右边。移动完成一轮后，看该数的下标（从0计数），如果刚好为k-1则它就是第k大的数，如果小于k-1，说明第k大的数在它右边，如果大于k-1则说明第k大的数在它左边，取左边或者右边继续进行移动，直到找到。**


这样时间复杂度虽然达不到O（n），但是比nlogn小很多。

**执行用时 :40 ms, 在所有C++提交中击败了41.12%的用户**

**内存消耗 :10.1 MB, 在所有C++提交中击败了12.72%的用户**

### **我对自己的快排深感怀疑。。。。**

#  别人家的快排

**执行用时 :8 ms, 在所有C++提交中击败了99.86%的用户**

**内存消耗 :9 MB, 在所有C++提交中击败了96.58%的用户**

**下次抽时间钻研钻研。可能是自己的方法和思维还是有问题。**

 
