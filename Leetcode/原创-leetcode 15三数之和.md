# 原创：leetcode 15三数之和

最开始的想法很简单，双指针遍历，查询，时间复杂度O（n^3），过不了最后几个案例。

 估摸着，空间换时间————用hash存元素，然后进行遍历。

时间复杂度：

1.遍历vector——n。

2.双指针遍历数组——n^2.  hash:log2n（红黑树查找）

-&gt;n+n^2*logn=O（n^2*logn）

可以一试；

万万没想到还是超时。惨绝人寰，丧心病狂！！！！！

 

最后看了一下标准解法：

1.排序。

2.定位一个，然后用类似快排的手法，两边往中间移动，加上适当剪枝。一次可以检索出一个数字对应的所有情况。

剪枝：

> 
<p>if (nums[i] &gt; 0){<br/>
                break;<br/>
            }<br/>
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]){<br/>
                continue;<br/>
            }</p>


时间复杂度等于是：

排序：n*log2(n)

内部：n*n（类似于两遍遍历数组），一次可以找出一对。比一个个找快多了。

总的时间复杂度  O（n^2）

 

 
