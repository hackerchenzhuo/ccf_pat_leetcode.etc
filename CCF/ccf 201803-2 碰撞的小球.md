# 原创：ccf 201803-2 碰撞的小球

 ![](https://img-blog.csdnimg.cn/20190309193643120.png)

感觉自己的方法应该不是最优的，但是也还算清晰。若有更好的方法欢迎指出。

 

问题描述

　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。<br/>
　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。<br/>
　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。<br/>
　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。

提示

　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。<br/>
　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。

输入格式

　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。<br/>
　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。

输出格式

　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。

样例输入

3 10 5<br/>
4 6 8

样例输出

7 9 9

```c++
//18.56-19.35
 
#include<iostream>
 
using namespace std;
 
struct ball{
	int x;
	int way;//-1:左。1：右 
	ball(){
		way=1;
	}
};
 
int n, L, t;//分别表示小球的个数、线段长度L和你需要计算t秒之后小球的位置。
ball a[105];//a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。
int num_of_ball[10000]={0};
void move()
{
	for(int i=0;i<n;i++)//对每个小球处理 
	{
		if(num_of_ball[a[i].x]>=2)//先判重合 
		{
			a[i].way=(-1)*a[i].way;
			for(int j=0;j<n;j++)//找和他重合的另一个球。 
			{
				if(j!=i&&a[j].x==a[i].x)
				{
					a[j].way=(-1)*a[j].way;
				}
			}
		}
		num_of_ball[a[i].x]--;
		a[i].x+=a[i].way;//再移动 
		num_of_ball[a[i].x]++;
		
		if(a[i].x==L||a[i].x==0)
		{
			a[i].way=(-1)*a[i].way;
		}
		
	}
}
int main()
{
	//1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 < ai < L。L为偶数。
	cin>>n>>L>>t;
	for(int i=0;i<n;i++)
	{
		cin>>a[i].x;
		num_of_ball[a[i].x]++;//记录该坐标小球数量 
	}
	
	 for(int i=0;i<t;i++)//move t次 
	 {
	 	move();
	 }
	for(int i=0;i<n;i++)
	{
		cout<<a[i].x<<" ";
	}
	return 0;
	
 } 
 ```
 
