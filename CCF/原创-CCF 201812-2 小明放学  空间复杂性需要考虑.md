# 原创：CCF 201812-2 小明放学  空间复杂性需要考虑

这个其实做的挺顺的，用个next数组搞定，小数据上正确了，大数据不知道怎么搞的，第一次提交时貌似没过。
![](https://img-blog.csdnimg.cn/20190309203749340.png)

**感觉应该不是超时的问题。**

 

> 
题目背景
　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。
问题描述
　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了**出发时刻**路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。
输入格式
<p>　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。<br/>
　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。<br/>
　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示**出发时刻**，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。</p>
输出格式
　　输出一个数字，表示此次小明放学回家所用的时间。
样例输入
30 3 30
8
0 10
1 5
0 11
2 2
0 6
0 3
3 10
0 3
样例输出
46
样例说明
　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。
评测用例规模与约定
<p>　　有些测试点具有特殊的性质：<br/>
　　* 前 2 个测试点中不存在任何信号灯。<br/>
　　测试点的输入数据规模：<br/>
　　* 前 6 个测试点保证 n ≤ 10^3。<br/>
　　* 所有测试点保证 n ≤ 10^5。</p>


**试了几次都百思不得其解。**

**然后再一次读题，发现了一个惊天大秘密：all可能超int范围: 10^5 *10^2=10^7,(诶不对啊，int的最大值不是2*10^9吗。。。)**

> 
3.16日更新：
不过现在明白了，这是一个特殊情况：
**如果前面全部没有信号灯，则all一直累积，最大可以达到：（r+y+g）*10^5，也就是接近3*10^11，这明显超了int范围。不过有一种方法可以避免不用longlong，那就是每一次all的累积都mod（r+y+g）。这样就行了（我不是每一次mod，而是计算的时候才mod，所以不能避免这种情况，因此用long long）**


**反正不管三七二十一，改成long long 就过了。。。付出了空间的代价，不过影响不大。顺便我还把程序优化了一下，每一次计算的时候吧all mod一下r+y+g，这样快几倍。**

 
![](https://img-blog.csdnimg.cn/20190309204903626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzQ2Nzkx,size_16,color_FFFFFF,t_70)
附上c++代码：

```c++
//小明放学
//20.08-20.45
 
#include<iostream>
using namespace std;
long long  num[100005][2];
int next[4]={0,3,1,2};//next数组记录下一个状态 .绿->黄->红:  3g->2y->1r->3g 
int time[4]={0}; //time数组记录时间 
int n;
long long all=0;//到目前为止所用的时间
int main()
{
	int r,y,g;
	cin>>r>>y>>g;//
	time[1]=r;
	time[2]=y;
	time[3]=g;
	cin>>n;
 
	 
	for(int i=0;i<n;i++)//k=1、2、3 时，分别表示出发时刻，此处的红绿灯状态是红灯、黄灯、绿灯，
	{
		cin>>num[i][0];
		cin>>num[i][1];
	}
	
	for(int i=0;i<n;i++)//绿->黄->红:  3g->2y->1r->3g 
	{
		if(num[i][0]!=0)//有信号灯 
		{
			num[i][1]-=(all%(r+y+g));
			while(num[i][1]<0)
			{
				num[i][0]=next[num[i][0]];//状态转换 
				num[i][1]=time[num[i][0]]+num[i][1];//时间转换 	
			}
		}
		//下面的同小明上学 
		if(num[i][0]!=3)
		{
			all+=num[i][1];
		}
		if(num[i][0]==2)
		{
			all+=r;
		}
 
	}	
	cout<<all;
	return 0;
 } 
 ```
 
 
